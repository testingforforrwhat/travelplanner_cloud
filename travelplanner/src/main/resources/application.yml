server:
  port: 8081

spring:
  profiles:
    # ??????? dev ???? / test ????  / prod ????
    active: dev-secrets
  servlet:
    multipart:
      max-file-size: 100MB # File upload limit, default 1MB not enough.
      max-request-size: 100MB # 总请求体最大200MB（例如一次上传多个文件）
      enabled: true # 是否启用多部分上传功能，默认为true
      file-size-threshold: 0B # 文件大小阈值，超过该值会写入磁盘临时文件，默认为0B
      location:  # 上传文件的临时存储位置
  jackson:
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      adjust-dates-to-context-time-zone: false
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: Asia/Shanghai
  config:
    import:
      - optional:nacos:application.yml  # 从 Nacos 导入配置
  # WARN 47916 --- [  restartedMain] c.a.c.n.registry.NacosServiceRegistry    : No service to register for nacos client...
  # 如果你希望把当前应用注册到 Nacos（推荐）
  application:
    # discovery - enabled - true - nacos - 服务管理 - 服务列表
    # 当前服务的名称
    name: travelplanner    # 必须配置应用名
  cloud:
    nacos:
      discovery:
        enabled: true    # 打开服务发现/注册功能
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
        username: ${NACOS_USERNAME:nacos}
        password: ${NACOS_PASSWORD:nacos}
        namespace: ${NACOS_NAMESPACE:public}
      config:
        # nacos 配置中心的网络域
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
        # nacos 配置中心的配置文件类型（yaml 或 properties）
        file-extension: yaml
        username: ${NACOS_USERNAME:nacos}
        password: ${NACOS_PASSWORD:nacos}
        # nacos 配置中心的命名空间 http://127.0.0.1:8848/nacos/ 新建命名空间
        namespace: ${NACOS_NAMESPACE:public}
        # nacos 配置中心的分组
        group: DEFAULT_GROUP
        # 共享配置
        shared-configs:
          - data-id: gateway-routes.yaml
            group: DEFAULT_GROUP
            refresh: true
#    gateway:
#      discovery:
#        locator:
#          # 比如你有订单服务 order-service 也注册到了 Nacos，网关自动可以转发到：
#          #http://localhost:8081/order-service/api/orders/...
#          enabled: true # 开启从 nacos 注册中心动态创建路由
#          lower-case-service-id: true # 服务名小写
    sentinel:
      enabled: true
      transport:
        dashboard: localhost:8858  # Sentinel 控制台地址（如用控制台监控）

    openfeign:
      # oauth2.enabled: true：Feign 自动通过你配置的 mapTest 客户端去拿 AccessToken，所有 Feign 请求都自动带上 Bearer Token; Bearer Token 是 default-request-headers 之一;
      #
      # 不需要写拦截器/切换手动逻辑，全部用配置即可
      # 自动获取 OAuth2 clientRegistrationId token，并附在 Authorization: Bearer token
      oauth2:
        enabled: true
        # clientRegistrationId: mapTest
        clients:
          map-api: # ----- Maps API FeignClient专用
            clientRegistrationId: mapTest
          weather-api: # ----- 天气API FeignClient专用
            clientRegistrationId: weatherTest
      client:
        # 每个不同的 API，定义一个不同的 Feign 接口和配置块
        config:
          map-api:
            url: https://routes.googleapis.com/directions/v2:computeRoutes
            loggerLevel: basic
            # 每次请求自动加上指定请求头，不需要在代码里 set。
            default-request-headers:
              X-Goog-FieldMask: ${X-Goog-FieldMask}
            # default-query-parameters：每次请求自动加上 key 等参数
            default-query-parameters:
              key: ${key}
          weather-api:
            url: https://apis.map.qq.com/ws/place/v1/suggestion
            loggerLevel: basic
            default-query-parameters:
              key: ${weather.api-key}
  # spring security OAuth2 Client，
  # 是 spring boot/spring security 用来作为OAuth2客户端去主动“代表应用请求授权、登录、获取资源”
  #
  # spring security OAuth2 Client 是一个简化 OAuth2/OIDC 客户端集成的强大组件，可以使得你的应用轻松与第三方认证服务器（如 Google、GitHub、微信等）集成。
  #
  # Spring Security OAuth2 Client 是 Spring Security 5.x+ 的重要组件，用于帮助应用连接 OAuth2/OpenID Connect 服务、获取令牌、并使用令牌访问受保护资源。
  # Spring Security OAuth2 Client 主要用于管理 OAuth2 客户端身份，自动处理第三方API访问时的认证授权，常用于：
  # - 获取并管理 OAuth2 Access Token（无论是 client_credentials、authorization_code、password、或 refresh_token 流程）
  # - 自动添加 Authorization Header
  # - 与 OpenFeign 或 RestTemplate 集成，实现无感知安全请求
  #
  # 服务本身作为 OAuth2 Client 调用第三方API
  # 如：
  # - 服务端后台自动调用 Google、Twitch、微信等第三方API, 获取访问令牌 / 自动令牌刷新 / 令牌存储/缓存
  # - 微服务间调用时，每个服务都做自己的认证授权
  #
  #
  # 代表**当前应用（作为Client）**去认证服务器（如 Google、GitHub、阿里云、Twitch、微信等）获取token
  # 管理token的存储、刷新、传递
  # 便于主动调用外部受保护API（和OAuth2 Login用户登录不一样，这边重点是“Server端-Server端”对接）
  #
  # OAuth2 认证流程支持
  # - 授权码模式（authorization_code）
  # - 客户端模式（client_credentials）
  #    ' 多种客户端类型
  #      - 普通Web应用（对接第三方登录/API）
  #      - 纯后端应用（服务间调用）
  #      - 前后端分离的SPA
  # - 密码模式（password）
  # - 刷新令牌（refresh_token）
  #
  # Spring Security OAuth2 Client 的最大好处是极大简化了安全集成，不用再手动获取和维护 token，特别适合：
  # - 后台服务调用第三方
  # - 企业内部对接 OpenFeign
  # - 微服务链路自动安全化
  #
  #
  # Spring Security OAuth2 Client 是一个简化 OAuth2/OIDC 客户端集成的强大组件，可以使得你的应用轻松与第三方认证服务器（如 Google、GitHub、微信等）集成。详细解析：
  #
  #一、核心功能
  # 身份认证：通过 OAuth2/OIDC 协议实现用户登录
  # 资源访问：获取令牌访问受保护资源
  # 令牌管理：自动处理令牌获取、刷新和失效
  # 客户端注册：集中管理多个 OAuth2 提供商
  #二、常见使用场景
  # 三方登录：让用户用 Google/微信/支付宝等账号登录你的应用
  # API授权：应用代表用户调用第三方API（如发推、发微博）
  # 微服务间通信：服务A代表用户调用服务B (Token Relay)
  #后台API调用：使用 client_credentials 流程访问API（不涉及用户）
  #
  # implementation 'org.springframework.security:spring-security-oauth2-client
  #
  # <!-- Spring Boot 项目 -->
  # <dependency>
  #    <groupId>org.springframework.boot</groupId>
  #    <artifactId>spring-boot-starter-oauth2-client</artifactId>
  # </dependency>
  #
  # 核心组件
  # ClientRegistration：OAuth2客户端注册信息
  # OAuth2AuthorizedClient：授权成功后的客户端，包含令牌
  # OAuth2AuthorizedClientRepository：存储授权客户端的位置
  # OAuth2AuthorizedClientService：管理授权客户端
  # OAuth2AuthorizedClientManager：协调授权流程
  security:
    oauth2:
      client:
        # 如果不同 API 使用不同的认证体系，要分别配置 OAuth2 客户端
        registration:
          # 登录集成第三方OAuth2服务, 常见如：GitHub、Google、Facebook、WeChat等登录
          # registration名
          # 授权码模式（网站登录）
          github:
            # OAuth2 认证授权类型
            authorization-grant-type: authorization_code
            client-id: ${github.client.id}
            client-secret: ${github.client.secret}
            redirect-uri: "{baseUrl}/login/oauth2/code/github"
            scope: [ user, email ]
          # 后端服务调用OAuth2保护的API, 如对接支付、云服务、第三方开放平台API
          # registration名
          twitch:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            # 客户端认证方式
            client-authentication-method: client_secret_post
            # OAuth客户端ID
            client-id: ${Client-Id}
            # OAuth客户端密钥
            client-secret: ${client-secret}
          # 后端服务调用OAuth2保护的API, 如对接支付、云服务、第三方开放平台API
          # registration名
          #
          # fix: Provider ID must be specified for client registration 'message-service'
          # fix: 错误发生的关键原因是：
          #      - Spring Boot 启动时创建 InMemoryClientRegistrationRepository Bean
          #      - 检查到 message-service 客户端注册（client_credentials registration）未指定 provider，导致实例化失败
          # 当你配置 Spring Security OAuth2 Client 时，每个客户端注册（client_credentials registration）必须:
          # - 指定一个 provider 属性
          # - 这个 provider 必须在配置中有对应定义
          # 确保你的配置：
          # - 每个 registration 有对应的 provider 属性
          # - 每个被引用的 provider 名称在 provider 部分有定义
          # - provider 至少有 token-uri 属性（client_credentials 模式必需）
          payment-service:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            client-id: ${payment.client.id}
            client-secret: ${payment.client.secret}
          # 微服务间安全通信, 服务A调用受保护的服务B接口
          # registration名
          message-service:
            # OAuth2 认证授权类型
            authorization-grant-type: client_credentials
            client-id: ${message.client.id}
            client-secret: ${message.client.secret}
        # 当你配置 Spring Security OAuth2 Client 时，每个客户端注册（client_credentials registration）必须:
        # - 指定一个 provider 属性
        # - 这个 provider 必须在配置中有对应定义
        # 确保你的配置：
        # - 每个 registration 有对应的 provider 属性
        # - 每个被引用的 provider 名称在 provider 部分有定义
        # - provider 至少有 token-uri 属性（client_credentials 模式必需）
        #
        # 内置Provider：Spring支持一些内置provider如Google、GitHub、Okta，使用时只需指定名称无需定义endpoint。
        provider:
          # 与上面registration名要一致
          twitch:
            # 令牌端点
            token-uri: https://id.twitch.tv/oauth2/token
          # 与上面registration名要一致
          payment-service:
            # 令牌端点
            token-uri: https://id.twitch.tv/oauth2/token
          # 与上面registration名要一致
          message-service:
            # 令牌端点
            token-uri: https://id.twitch.tv/oauth2/token
  datasource:
    url: jdbc:postgresql://${DATABASE_URL:localhost}:${DATABASE_PORT:5432}/postgres
    username: ${DATABASE_USERNAME:postgres}
    password: ${DATABASE_PASSWORD:secret}
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      # Do not perform any DDL operations. This is the default setting, suitable for situations where Hibernate is not desired to automatically manage the database structure.
      #      ddl-auto: none
      #      ddl-auto: update: This will automatically update the database schema to match the entity classes when the application starts. Other options include none, create (recreate tables on each startup), and validate (verify that the table structure matches the entity classes).
      ddl-auto: create-drop
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
    database-platform: org.hibernate.spatial.dialect.postgis.PostgisDialect
    show-sql: true
  sql:
    init:
      mode: always
      # schema-locations: "classpath:postgis_extension.sql,classpath:database-init.sql"
      # data-locations: "classpath:config-data.sql"
  # Redis 配置
  redis:
    host: ${SPRING_REDIS_HOST:localhost}
    port: ${SPRING_REDIS_PORT:6379}
    timeout: 10000
  # kafka - docker container ( docker-compose.yml ) + 宿主机 ( application.yml )
  # Kafka 配置
  kafka:
    bootstrap-servers: ${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9093}
    producer:
      # key-serializer: org.apache.kafka.common.serialization.StringSerializer
      # value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      properties:
        spring.json.add.type.headers: false
    consumer:
      group-id: order-service-group
      auto-offset-reset: earliest
      # key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      # value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      properties:
        spring.json.trusted.packages: com.example.orderservice.dto,com.example.orderservice.event

# Resilience4j 配置
resilience4j:
  # 建议同时使用限流和断路器：
  # - 限流防止流量冲击 ( 控制请求速率(控制本方法调用次数)，防止本系统过载 )
  # - 断路器防止故障扩散 ( 本方法调用依赖系统(检测本方法调用 success 次数),错误率达到阈值（如50%）或响应超时,快速失败，防止级联故障，防止依赖系统过载 )
  # - 两者互补，提供更全面的系统保护
  #
  # 熔断通常会触发降级，但降级不一定需要熔断(限流亦可)
  #
  # 正常流程：用户下单 → 调用库存服务 → 调用支付服务 → 生成订单
  #
  # 异常情况：
  # 1. 库存服务挂了 → 熔断器开启 → 降级：允许下单但标记为"待确认库存"
  # 2. 支付服务慢 → 超时熔断 → 降级：创建订单但支付状态为"待支付"
  # 3. 促销活动 → 流量激增 → 降级：关闭推荐服务，只保留核心下单流程
  #
  # 正常：查询用户详细信息（头像、等级、积分等）
  # 降级：只返回基本信息（用户名、ID）
  #
  #
  # 降级策略优先级
  # 本地缓存 > 数据库查询 > 默认值 > 友好错误提示
  circuitbreaker:
    instances:
      backendService:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        # 断路器打开状态持续时间
        waitDurationInOpenState: 10s
        # 本方法调用依赖系统,失败率50%触发断路器
        failureRateThreshold: 50
        permittedNumberOfCallsInHalfOpenState: 3
        slowCallRateThreshold: 100
        slowCallDurationThreshold: 60s
      orderService:
        slidingWindowSize: 20
        failureRateThreshold: 60
        waitDurationInOpenState: 15s
  # 限流器配置
  ratelimiter:
    instances:
      backendService:
        # 每个周期内允许的请求数
        limitForPeriod: 1
        # 刷新周期
        limitRefreshPeriod: 10s
        # 获取许可的超时时间; 立即超时
        timeoutDuration: 0s
      orderServiceLimiter:
        limitForPeriod: 1
        limitRefreshPeriod: 10s
        timeoutDuration: 1s
  # 重试配置 (可选)
  retry:
    instances:
      backendService:
        maxAttempts: 3
        waitDuration: 1s
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2

logging:
  level:
    org.apache.coyote.http11.Http11InputBuffer: TRACE # Incoming http requests
    org.springframework.jdbc.core: DEBUG # SQL
    org.springframework.jdbc.datasource.init: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

travelplanner:
  gcs:
    bucket: travelplanner-bucket-1
  geocoding:
    key:
  jwt:
    secret-key: 868q0lpi6O/0bTW94LCvjF4/grS8DJuvwBVLrgnLCLs=

# https://platform.deepseek.com/
# https://api-docs.deepseek.com/zh-cn/
deepseek:
  api-key: ${deepseek.api-key}
  base-url: ${deepseek.base-url}  # DeepSeek 的 API 基础 URL
  model: ${deepseek.model}  # 使用的模型名称
  stream: ${deepseek.stream}  # # 开启流式输出

tencent:
  api-key: ${weather.api-key}
  cos:
    secret-id: ${tencent_cos_secret-id}       # 替换为你的 SecretId
    secret-key: ${tencent_cos_secret-key}     # 替换为你的 SecretKey
    region: ${tencent_cos_region}            # 替换为你的存储桶所在的区域
    bucket-name: ${tencent_cos_bucket-name}   # 替换为你的存储桶名称

# 开启 Sentinel 监控端点
management:
  endpoints:
    web:
      exposure:
        include: "*"