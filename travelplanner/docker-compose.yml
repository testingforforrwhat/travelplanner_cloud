version: '3.8'


services:

  backend:
    # 如果 Spring Boot、vuecli等 镜像已用 bootBuildImage、dockerfile等 生成，可以省略 build，image 名即上一步build的名称。
    # 不写 build: 字段，否则本地会重新 build 镜像。
    # docker-compose up 会自动判断本地无此镜像时，从远程仓库下载。
    # 镜像名必须和 build/push 时一致。
    #
    # 只要 build 字段存在，compose 会优先用本地源码和Dockerfile重新构建出镜像，而不是去远程仓库拉镜像。
    # 一般线上/生产，只写 image 字段，保证镜像一致性和拉取提升速度。开发测试、需要自定义镜像时才用 build 字段。
    #
    # 最佳实践
    # - 使用远程稳定镜像：对于 ElasticSearch、Redis、MySQL 等基础服务，直接用 image: 指定官方镜像
    # - 开发中的应用：如果频繁修改代码，使用 build: 方便开发调试
    # - CI/CD 管道中：构建一次镜像，推送到私有仓库，然后在生产环境只使用 image: 拉取
    build: # 表示要用 Dockerfile 自动构建镜像。
      # 就是让 Docker 从 vuecli-app (前端项目根目录) 目录下查找 Dockerfile 并把这个目录及内容作为构建所需文件传给 Docker 引擎。
      # 这样就可以 COPY . . 把代码复制进镜像里。
      context: ../travelplanner
    image: ccr.ccs.tencentyun.com/travelplanner/springboot-app-travelplanner-image:latest
    user: root  # 临时使用 root 用户运行（仅开发环境，生产不推荐）
    depends_on:
      - db
    ports:
      - "8081:8081"
    # Spring Boot 的配置优先级大致如下（高→低）,高优先级覆盖低优先级：
    # - 命令行参数
    # - 环境变量
    # - application.yml 或 application.properties
    # - 代码中的默认值等
    #
    # 所以你在 docker-compose.yml 写的
    # environment:
    #   SPRING_DATASOURCE_URL: jdbc:mysql://db:3306/testdb
    # 等价于设置了环境变量，只会覆盖这几个指定的项，不会影响 application.yml 里其它没有覆盖的配置。
    environment:
      # 数据库配置
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/postgres
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: secret
      # java.nio.file.AccessDeniedException: /workspace/uploads, 这表示 容器内的 /workspace/uploads 目录没有写权限或者当前用户没有权限访问该目录。
      # 你的配置，uploads 实际就是 /workspace/uploads。只需保证这个目录存在且有写权限，并用 volumes 把主机持久化目录映射到这里，问题即可解决。
      # 使用 bootBuildImage 或 Maven/Gradle 的 spring-boot:build-image 任务时，生成的镜像默认使用非 root 用户 (通常是 UID 1000) 运行应用，导致无法写入 /workspace/uploads 目录。
      #  - 方法一: user: root  # 临时使用 root 用户运行（仅开发环境，生产不推荐）
      #  - 方法二: 修改 Dockerfile，确保目录存在并有正确权限
      #  - 方法三: 使用 volumes 挂载本地目录（并授权）
      FILE_UPLOAD_DIR: uploads
      # Redis 配置
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
      # Kafka 配置
      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:9092
      # 应用配置
      SERVER_PORT: 8081
    networks:
      - app-travelplanner-network

  db:
    image: ghcr.io/baosystems/postgis:latest
    restart: always
    environment:
      POSTGRES_DB: postgres
      POSTGRES_PASSWORD: secret
      TZ: UTC
    volumes:
      - travelplanner-pg-local:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - app-travelplanner-network

  redis:
    image: redis:7.2
    restart: always
    container_name: redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-travelplanner-network

  zookeeper:
    image: confluentinc/cp-zookeeper:7.3.0
    restart: always
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    networks:
      - app-travelplanner-network

  # 检查 Kafka 日志确认启动正常：docker-compose logs kafka
  # kafka - docker container ( docker-compose.yml ) + 宿主机 ( application.yml )
  kafka:
    image: confluentinc/cp-kafka:7.3.0
    restart: always
    container_name: kafka
    # 虽然我们在容器内监听了两个不同的端口（9092和9093），但通过端口映射，外部依然是通过本地的9092端口访问Kafka。
    #       - "9092:9092" - 可选
    #      - "9093:9093" - 必选
    ports:
      - "9092:9092"
      - "9093:9093"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      # KAFKA_LISTENERS: 指定 Kafka broker 监听的地址和端口
      #
      # 两个监听器（PLAINTEXT 和 PLAINTEXT_HOST）, 我们需要为不同的监听器指定不同的端口
      #
      # PLAINTEXT - docker 容器网络内部通信（比如 Spring Boot 容器使用 服务名访问: kafka:9092 访问）。
      # PLAINTEXT_HOST - 主机客户端（IDE 或 kafka tool）访问，用 localhost:29092。
      #
      # | 场景                | KAFKA_LISTENERS                        | KAFKA_ADVERTISED_LISTENERS             | ports                   |
      #|---------------------|----------------------------------------|-----------------------------------------|-------------------------|
      #| 仅容器内部通信      | PLAINTEXT://0.0.0.0:9092               | PLAINTEXT://kafka:9092, 告诉容器网络内的客户端，使用 kafka:9092 连接                 | 9092:9092               |
      #| 宿主机/本地也要连接 | PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:29092 | PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092, 告诉宿主机上的客户端，使用 localhost:29092 连接 | 9092:9092, 29092:29092  |
      #
      # 方案一：只用一个监听器（最简单且常用）
      # 删除 PLAINTEXT_HOST，只用 PLAINTEXT 即可（容器内部和外部都走 PLAINTEXT://0.0.0.0:9092）。
      #
      # 方案二：两个监听器但端口要不同（比如容器内监听 9092，容器外监听 9093）
      #
      # 推荐你优先用方案一，删除多余监听器, 然后重启 Kafka 容器即可。
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:9093
      # KAFKA_ADVERTISED_LISTENERS: 告诉客户端如何连接到 Kafka（内部用服务名，外部用localhost）
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:9093
      # # 定义安全协议
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      # 集群内部通信使用的监听器
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    depends_on:
      - zookeeper
    networks:
      - app-travelplanner-network

  # Kafka GUI管理工具(可选)
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    restart: always
    ports:
      - "8080:8080"
    environment:
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    depends_on:
      - kafka
    networks:
      - app-travelplanner-network

  # http://localhost:8848/nacos
  nacos:
    image: nacos/nacos-server:v2.3.2
    container_name: nacos
    environment:
      - MODE=standalone
      - NACOS_AUTH_ENABLE=true    # 打开鉴权（生产建议打开）
      - NACOS_AUTH_TOKEN=nQPZ70cV4TGH5k3l3AFn4DDW4Vh82CyyDrmc3Kn5inE=
      - NACOS_CORE_AUTH_SERVER_IDENTITY_KEY=nacos
      - NACOS_CORE_AUTH_SERVER_IDENTITY_VALUE=nacos
    ports:
      - "8848:8848"
      - "9848:9848"
    volumes:
      - ./nacos-data/logs:/home/nacos/logs
      - ./nacos-data/data:/home/nacos/data
    restart: always
    networks:
      - app-travelplanner-network

  # http://localhost:8858
  sentinel:
    image: bladex/sentinel-dashboard:1.8.6
    container_name: sentinel-dashboard
    ports:
      - "8858:8858"
    environment:
      - JAVA_OPTS=-Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080
    # 挂载数据目录，保证日志不会因容器重启丢失（日志目录为 /root/logs）。
    volumes:
      - ./sentinel-data/logs:/opt/sentinel/logs
    restart: always

# 如果你不显式定义网络，Docker Compose 会自动为所有服务创建一个默认的桥接网络（bridge）。
# 自定义网络：通过 networks 配置，你可以创建一个自定义的桥接网络，并将服务连接到该网络
#
# 每个服务都连接到 app-network 自定义网络。
# 容器可以通过服务名（如 db）互相通信，而不需要使用 IP 地址
#
# docker network ls  // 查看 Docker 网络
# docker network inspect app-network  // 查看 app-network 的所有容器
networks:
  app-travelplanner-network:
    driver: bridge

# permanent storage of data.
volumes:
  travelplanner-pg-local:
  redis-data: